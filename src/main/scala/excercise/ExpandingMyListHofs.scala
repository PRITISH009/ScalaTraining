package excercise

import scala.annotation.tailrec
import scala.runtime.Nothing$

object ExpandingMyListHofs extends App {

  abstract class MyList[+A] {
    val length: Int
    def isEmpty: Boolean
    def head: A
    def tail: MyList[A]
    def add[B >: A](ele: B): MyList[B]
    def printElements(): Unit = println("[" + this + "]")
    def map[B](transformer: A => B): MyList[B]
    def filter(predicate: A => Boolean): MyList[A]
    def ++[B >: A](list: MyList[B]): MyList[B]
    def flatMap[B](transformer: A => MyList[B]): MyList[B]
    def foreach(sideEffect: A => Unit): Unit
    def sort(comparator: (A, A) => Int): MyList[A]
    def zipWith[B,C](list: MyList[B], zip: (A, B) => C): MyList[C]
    def fold[B](init:B)(f: (B,A) => B): B
  }

  case object Empty extends MyList[Nothing] {
    override val length: Int = 0
    override def isEmpty: Boolean = true
    override def head: Nothing = throw new NoSuchElementException("No Head Found. List is Empty")
    override def tail: Nothing = throw new NoSuchElementException("No Tail Found. List is Empty")
    override def add[B >: Nothing](ele: B): MyList[B] = Cons(ele, Empty)
    override def toString: String = ""
    override def map[B](transformer: Nothing => B): MyList[B] = Empty
    override def filter(predicate: Nothing => Boolean): MyList[Nothing] = Empty
    override def ++[B >: Nothing](list: MyList[B]): MyList[B] = list
    override def flatMap[B](transformer: Nothing => MyList[B]): MyList[Nothing] = Empty
    override def foreach(sideEffect: Nothing => Unit): Unit = ()
    override def sort(comparator: (Nothing, Nothing) => Int): MyList[Nothing] = Empty
    override def zipWith[B,C](list: MyList[B], zip: (Nothing, B) => C): MyList[C] = {
      if(!list.isEmpty) throw new RuntimeException("Lists Do not have the same length")
      else Empty
    }
    override def fold[B](init: B)(f: (B, Nothing) => B): B = init
  }

  case class Cons[+A](h: A, t: MyList[A]) extends MyList[A] {
    override val length: Int = 1 + t.length
    override def isEmpty: Boolean = false
    override def head: A = h
    override def tail: MyList[A] = t
    override def add[B >: A](ele: B): MyList[B] = Cons(ele, this)
    override def toString: String = s"$h${if(t.isEmpty) then t else ", " + t}"
    override def map[B](transformer: A => B): MyList[B] = Cons(transformer(h), t.map(transformer))
    override def filter(predicate: A => Boolean): MyList[A] =
      if(predicate(h)) then Cons(h, t.filter(predicate)) else t.filter(predicate)
    override def ++[B >: A](list: MyList[B]): MyList[B] = Cons(h, t ++ list)
    override def flatMap[B](transformer: A => MyList[B]): MyList[B] = transformer(h) ++ t.flatMap(transformer)
    override def foreach(sideEffect: A => Unit): Unit = {
      sideEffect(h)
      t.foreach(sideEffect)
    }
    // Can I make this tail Recursive
    override def sort(comparator: (A, A) => Int): MyList[A] = {
      if(t.isEmpty) Cons(h, Empty)
      else {
        t.filter(ele => comparator(h, ele) > 0).sort(comparator) ++ Cons(h, Empty) ++ t.filter(ele => comparator(h, ele) < 0).sort(comparator)
      }
    }
    override def zipWith[B, C](list: MyList[B], zip: (A, B) => C): MyList[C] = {
      if(list.length != this.length) throw new RuntimeException("Lists Do not have the same length")
      else Cons(zip(h, list.head), t.zipWith(list.tail, zip))
    }
    override def fold[B](init: B)(f: (B,A) => B): B = t.fold(f(init,h))(f)
  }

  val list = Cons(1, Cons(2, Cons(3, Empty)))
  val secondList = Cons(4, Cons(5, Cons(6, Empty)))
  list.printElements()

  list.map(_ * 2).printElements()
  list.filter(_ % 2 == 0).printElements()

  (list ++ secondList).printElements()

  list.flatMap(x => Cons(x, Cons(x + 1, Empty))).printElements()

  // Expand MyList
  // - foreach Method A => Unit
  // [1,2,3].foreach(x => println(x)) // print each element on a new line
  list.foreach(println)

  // - sort function ((A, A) => Int) => MyList
  // [1,2,3].sort((x, y) => y-x) => [3,2,1]
  (list ++ secondList).sort((x, y) => y - x).printElements()

  // zipWith (list, (A, A) => B) => MyList[B]
  // [1,2,3].zipWith([4,5,6], x * y) => [1*4, 2*5, 3*6] = [4,10,18]
  println((list ++ secondList).length)
  list.zipWith(secondList, _*_).printElements()

  // fold(start)(function) => a value
  // [1,2,3].fold(0)(x+y) = 6
  println((list ++ secondList).fold(0)(_+_)) // Expects 21

  // 2. toCurry(f: (Int, Int) => Int) => (Int => Int => Int))
  // Converting a normal function to a curry function (so that it can be partially applied)
  // obviously the final value will be generated by the normal function provided
  def toCurry(f: (Int, Int) => Int): Int => Int => Int = x => y => f(x,y)

  //    fromCurry(f: (Int => Int => Int) => (Int, Int) => Int)
  // Converting back a Curried method to a normal function // obviously the value will be calculated
  // by the curry function provided.
  def fromCurry(f: Int => Int => Int): (Int, Int) => Int = {
    (x: Int, y: Int) => f(x)(y)
  }

  // 3. compose(f,g) => x => f(g(x))
  //    andThen(f,g) => x => g(f(x))

  // FunctionX
  def compose[A,B,T](f: A => B, g: T => A): T => B = x => f(g(x))
  def andThen[A, B, C](f: A => B, g: B => C): A => C = x => g(f(x))

  def superAdder: Int => Int => Int = toCurry(_ + _)
  def add4 = superAdder(4)
  println(add4(17)) // Should Print 21

  val simpleAdder = fromCurry(superAdder)
  println(simpleAdder(4, 17))

  val add2 = (x: Int) => x + 2
  val times3 = (x: Int) => x * 3

  val composed = compose(add2, times3)
  val ordered = andThen(add2, times3)

  println(composed)
  println(ordered)
}
